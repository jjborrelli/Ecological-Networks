med.sq.error <- function(pars, data = cell$surv){
int <- pars[1]
sl <- pars[2]
sig <- sqrt(pars[3])
y.pred <- sl * data + sl
y.err <- (data - y.pred)^2
return(median(y.err))
}
med.sq.error(c(-.69, -.59, var(cell$surv)))
dose <- c(1.175, 1.175, 2.35, 2.35, 4.7, 4.7, 4.7, 7.05, 7.05, 9.4, 9.4, 9.4, 14.1, 14.1)
surv.prob <- c(-.821, -.598, -1.833, -2.040, -3.219, -3.219, -2.794, -5.298, -5.745,
-6.812, -8.805, -8.568, -4.962, -9.721)
cell <- data.frame(plate_number = 1:14, dose = dose, surv = surv.prob)
med.sq.error(c(-.69, -.59, var(cell$surv)))
optim(c(-.69, -.59, var(cell$surv)), fn = med.sq.error)
?optim
rows <- 1:nrow(cell)
newdat <- sample(rows, nrow(cell), replace = T)
optim(c(-.69, -.59, var(cell$surv)), fn = med.sq.error, data = cell[newdat,])
rows <- 1:nrow(cell)
newdat <- sample(rows, nrow(cell), replace = T)
optim(c(-.69, -.59, var(cell$surv)), fn = med.sq.error, data = cell[newdat,])
boot.par <- matrix(nrow = 1000, ncol = 3)
for(i in 1:1000){
rows <- 1:nrow(cell)
newdat <- sample(rows, nrow(cell), replace = T)
opt.par <- optim(c(-.69, -.59, var(cell$surv)), fn = med.sq.error, data = cell[newdat,])
boot.par[i,] <- opt.par$par
}
boot.par <- matrix(nrow = 200, ncol = 3)
for(i in 1:200){
cat("\n", i)
rows <- 1:nrow(cell)
newdat <- sample(rows, nrow(cell), replace = T)
opt.par <- optim(c(-.69, -.59, var(cell$surv)), fn = med.sq.error, data = cell[newdat,])
boot.par[i,] <- opt.par$par
}
boot.par
optim(c(-.69, -.59, var(cell$surv)), fn = med.sq.error)
sd(boot.par)
apply(boot.par, 2, sd)
cell
1.5^2
data <- read.csv("~/Dropbox/Food Web Database/Food_Web/ele12264-sup-0005-Masterdata.csv")
data
head(data)
split(data, data$lake)
split1 <- split(data, data$lake)
length(split1)
split1[[1]]
split1[[1]]$period
lapply(split1, function(x){split(x, x$period)})
head(data)
split2 <- lapply(split1, function(x){split(x, x$period)})
split2[[1]]
split2[[1]][[1]]
data$pool
split1<- split(data, data$pool)
split1 <- split(data, data$pool)
length(split1)
split1[[1]]
split1[[1]]$period == 1
split[[1]][split1[[1]]$period == 1]
split1[[1]][split1[[1]]$period == 1]
split1[[1]][split1[[1]]$period == 1,]
test1 <- split1[[1]][split1[[1]]$period == 1,]
matrix(c(test1$pred_ID, test1$prey_ID), nrow = 5, ncol = 2)
edge1 <- matrix(c(test1$pred_ID, test1$prey_ID), nrow = 5, ncol = 2)
plot.igraph(graph.edgelist(edge1))
require(igraph)
plot.igraph(graph.edgelist(edge1))
edge1
graph.edgelist(edge1)
plot.igraph(graph.edgelist(as.character(edge1)))
edge1 <- matrix(c(as.character(test1$pred_ID), as.character(test1$prey_ID)), nrow = 5, ncol = 2)
plot.igraph(graph.edgelist(edge1)))
plot.igraph(graph.edgelist(edge1))
test2 <- split1[[1]][split1[[1]]$period == 2,]
edge2 <- matrix(c(as.character(test2$pred_ID), as.character(test2$prey_ID)), nrow = 5, ncol = 2)
test2$pred_ID
test2
test1
test1 <- split1[[1]][split1[[1]]$period == 1,]
edge1 <- matrix(c(as.character(test1$prey_ID), as.character(test1$pred_ID)), nrow = 5, ncol = 2)
plot.igraph(graph.edgelist(edge1))
test2 <- split1[[1]][split1[[1]]$period == 2,]
edge2 <- matrix(c(as.character(test2$pred_ID), as.character(test2$prey_ID)), nrow = 4, ncol = 2)
plot.igraph(graph.edgelist(edge2))
edge2 <- matrix(c(as.character(test2$prey_ID), as.character(test2$pred_ID)), nrow = 4, ncol = 2)
plot.igraph(graph.edgelist(edge2))
plot.igraph(graph.edgelist(edge1))
plot.igraph(graph.edgelist(edge2))
test3 <- split1[[1]][split1[[1]]$period == 3,]
test3
edge3 <- matrix(c(as.character(test3$prey_ID), as.character(test3$pred_ID)), nrow = 10, ncol = 2)
plot.igraph(graph.edgelist(edge3))
test4 <- split1[[1]][split1[[1]]$period == 4,]
test4
dim(test4)
edge4 <- matrix(c(as.character(test4$prey_ID), as.character(test4$pred_ID)), nrow = 15, ncol = 2)
plot.igraph(graph.edgelist(edge4))
## Create matrices for each of the 13 possible 3 species configurations
# "s" denotes single links only
s1<-matrix(c(0,1,0,-1,0,1,0,-1,0),nrow=3,ncol=3)
s2<-matrix(c(0,1,1,-1,0,1,-1,-1,0),nrow=3,ncol=3)
s3<-matrix(c(0,1,-1,-1,0,1,1,-1,0),nrow=3,ncol=3)
s4<-matrix(c(0,0,1,0,0,1,-1,-1,0),nrow=3,ncol=3)
s5<-matrix(c(0,1,1,-1,0,0,-1,0,0),nrow=3,ncol=3)
# "d" denotes that double links are included
d1<-matrix(c(0,1,1,1,0,1,-1,-1,0),nrow=3,ncol=3)
d2<-matrix(c(0,1,1,-1,0,1,-1,1,0),nrow=3,ncol=3)
d3<-matrix(c(0,1,1,1,0,0,-1,0,0),nrow=3,ncol=3)
d4<-matrix(c(0,1,1,-1,0,0,1,0,0),nrow=3,ncol=3)
d5<-matrix(c(0,1,1,-1,0,1,1,-1,0),nrow=3,ncol=3)
d6<-matrix(c(0,1,1,1,0,1,1,1,0),nrow=3,ncol=3)
d7<-matrix(c(0,1,1,1,0,1,1,-1,0),nrow=3,ncol=3)
d8<-matrix(c(0,1,1,1,0,0,1,0,0),nrow=3,ncol=3)
# Create a list of all 13 matrices
mot.lst <- list(s1, s2, s3, s4, s5, d1, d2, d3, d4, d5, d6, d7, d8)
names(mot.lst) <- c("s1", "s2", "s3", "s4", "s5", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8")
## Functions to get eigenvalues of randomly sampled matrices
ran.unif <- function(motmat){
newmat <- apply(motmat, c(1,2), function(x){
if(x==1){runif(1, 0, 1)}else if(x==-1){runif(1, -1, 0)} else{0}
})
diag(newmat) <- runif(1, -1, 0)
return(newmat)
}
maxRE <- function(rmat){
lam.max <- max(Re(eigen(rmat)$values))
return(lam.max)
}
### Wrap previous two functions together
eig.analysis <- function(n, matrices, mode = "unif"){
cols <- length(matrices)
rows <- n
eigenMATRIX <- matrix(nrow = rows, ncol = cols)
for(i in 1:n){
if(mode == "unif"){
ranmat <- lapply(matrices, ran.unif)
}else if(mode == "lnorm"){
ranmat <- lapply(matrices, ran.lnorm)
}
eigs <- sapply(ranmat, maxRE)
eigenMATRIX[i,] <- eigs
}
return(eigenMATRIX)
}
n <- 10000
system.time(
mot.stab<- eig.analysis(n, mot.lst, mode = "unif")
)
colnames(mot.stab) <- names(mot.lst)
require(reshape2)
m <- melt(mot.stab)
m.l <- melt(mot.stab.l)
require(ggplot2)
ggplot(m, aes(x = Var2, y = value)) + geom_boxplot() + geom_hline(aes(yintercept = 0))
ggplot(m.l, aes(x = Var2, y = value)) + geom_boxplot() + geom_hline(aes(yintercept = 0))
# Unif
mot.qss <- apply(mot.stab, 2, function(x){sum(x<0)/n})
sorted <- sort(mot.qss, decreasing = T)
sort.qss <- data.frame(sorted, names = names(sorted))
#Lnorm
mot.qss.l <- apply(mot.stab.l, 2, function(x){sum(x<0)/n})
sorted.l <- sort(mot.qss.l, decreasing = T)
sort.qss.l <- data.frame(sorted.l, names = names(sorted))
# Read in and reshape subgraph frequency data
motcount <- read.csv("~/Desktop/GitHub/Ecological-Networks/FoodWebs/Tables/zscore_both.csv", row.names = 1)
df.freq <- data.frame(motcount)
mfreq <- melt(df.freq[,names(sorted)])
g <- ggplot(mfreq, aes(x = variable, y = value)) + geom_boxplot()
g <- g + geom_line(data = sort.qss, aes(x = 1:13, y = sorted), size = 1.5)
g <- g + geom_point(data = sort.qss, aes(x = 1:13, y = sorted), size = 4, col = "blue")
g <- g + geom_line(data = sort.qss.l, aes(x = 1:13, y = sorted.l), size = 1.5)
g <- g + geom_point(data = sort.qss.l, aes(x = 1:13, y = sorted.l), size = 4, col = "darkred")
g <- g + geom_hline(aes(yintercept = 0), lty = 2, col = "red")
g + xlab("Subgraph") + ylab("Frequency")
data <- read.csv("~/Dropbox/Food Web Database/Food_Web/ele12264-sup-0005-Masterdata.csv")
head(data)
data$period
data$distance
data$inoculated
data$pool
split1 <- split(data, data$pool)
length(split1)
require(igraph)
test1 <- split1[[1]][split1[[1]]$period == 1,]
edge1 <- matrix(c(as.character(test1$prey_ID), as.character(test1$pred_ID)), nrow = 5, ncol = 2)
plot.igraph(graph.edgelist(edge1))
test2 <- split1[[1]][split1[[1]]$period == 2,]
edge2 <- matrix(c(as.character(test2$prey_ID), as.character(test2$pred_ID)), nrow = 4, ncol = 2)
plot.igraph(graph.edgelist(edge2))
test3 <- split1[[1]][split1[[1]]$period == 3,]
edge3 <- matrix(c(as.character(test3$prey_ID), as.character(test3$pred_ID)), nrow = 10, ncol = 2)
plot.igraph(graph.edgelist(edge3))
test4 <- split1[[1]][split1[[1]]$period == 4,]
edge4 <- matrix(c(as.character(test4$prey_ID), as.character(test4$pred_ID)), nrow = 15, ncol = 2)
plot.igraph(graph.edgelist(edge4))
height <- c(10, 12, 12, 13, 9, 11, 11, 12, 12,13, 15, 16)
height <- c(10, 12, 12, 13, 9, 11, 11, 12, 12,13, 15, 16)
treat <- factor(c("A","A","A","A", "B","B","B","B","C","C","C","C"))
df <- data.frame(height = height, treat = treat)
df
?anova
lm(height~treat)
lin <- lm(height~treat)
anova(lin)
aov(lin)
anova(lin)
22+19
mean(height)
## Create matrices for each of the 13 possible 3 species configurations
# "s" denotes single links only
s1<-matrix(c(0,1,0,-1,0,1,0,-1,0),nrow=3,ncol=3)
s2<-matrix(c(0,1,1,-1,0,1,-1,-1,0),nrow=3,ncol=3)
s3<-matrix(c(0,1,-1,-1,0,1,1,-1,0),nrow=3,ncol=3)
s4<-matrix(c(0,0,1,0,0,1,-1,-1,0),nrow=3,ncol=3)
s5<-matrix(c(0,1,1,-1,0,0,-1,0,0),nrow=3,ncol=3)
# "d" denotes that double links are included
d1<-matrix(c(0,1,1,1,0,1,-1,-1,0),nrow=3,ncol=3)
d2<-matrix(c(0,1,1,-1,0,1,-1,1,0),nrow=3,ncol=3)
d3<-matrix(c(0,1,1,1,0,0,-1,0,0),nrow=3,ncol=3)
d4<-matrix(c(0,1,1,-1,0,0,1,0,0),nrow=3,ncol=3)
d5<-matrix(c(0,1,1,-1,0,1,1,-1,0),nrow=3,ncol=3)
d6<-matrix(c(0,1,1,1,0,1,1,1,0),nrow=3,ncol=3)
d7<-matrix(c(0,1,1,1,0,1,1,-1,0),nrow=3,ncol=3)
d8<-matrix(c(0,1,1,1,0,0,1,0,0),nrow=3,ncol=3)
# Create a list of all 13 matrices
mot.lst <- list(s1, s2, s3, s4, s5, d1, d2, d3, d4, d5, d6, d7, d8)
names(mot.lst) <- c("s1", "s2", "s3", "s4", "s5", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8")
## Functions to get eigenvalues of randomly sampled matrices
ran.unif <- function(motmat){
newmat <- apply(motmat, c(1,2), function(x){
if(x==1){runif(1, 0, 10)}else if(x==-1){runif(1, -1, 0)} else{0}
})
diag(newmat) <- runif(1, -1, 0)
return(newmat)
}
### using a lognormal
ran.lnorm <- function(motmat){
newmat <- apply(motmat, c(1,2), function(x){
if(x==1){rlnorm(1, -1, 1)}else if(x==-1){-rlnorm(1, -5, 1)} else{0}
})
diag(newmat) <- -rlnorm(1, -5, 1)
return(newmat)
}
### Calculate largest eigenvalue (the real part)
maxRE <- function(rmat){
lam.max <- max(Re(eigen(rmat)$values))
return(lam.max)
}
### Wrap previous two functions together
eig.analysis <- function(n, matrices, mode = "unif"){
cols <- length(matrices)
rows <- n
eigenMATRIX <- matrix(nrow = rows, ncol = cols)
for(i in 1:n){
if(mode == "unif"){
ranmat <- lapply(matrices, ran.unif)
}else if(mode == "lnorm"){
ranmat <- lapply(matrices, ran.lnorm)
}
eigs <- sapply(ranmat, maxRE)
eigenMATRIX[i,] <- eigs
}
return(eigenMATRIX)
}
## Run with uniform
n <- 10000
system.time(
mot.stab<- eig.analysis(n, mot.lst, mode = "unif")
)
colnames(mot.stab) <- names(mot.lst)
## Run with lognormal
n <- 10000
system.time(
mot.stab.l<- eig.analysis(n, mot.lst, mode = "lnorm")
)
colnames(mot.stab.l) <- names(mot.lst)
require(reshape2)
m <- melt(mot.stab)
m.l <- melt(mot.stab.l)
require(ggplot2)
ggplot(m, aes(x = Var2, y = value)) + geom_boxplot() + geom_hline(aes(yintercept = 0))
ggplot(m.l, aes(x = Var2, y = value)) + geom_boxplot() + geom_hline(aes(yintercept = 0))
# Unif
mot.qss <- apply(mot.stab, 2, function(x){sum(x<0)/n})
sorted <- sort(mot.qss, decreasing = T)
sort.qss <- data.frame(sorted, names = names(sorted))
#Lnorm
mot.qss.l <- apply(mot.stab.l, 2, function(x){sum(x<0)/n})
sorted.l <- sort(mot.qss.l, decreasing = T)
sort.qss.l <- data.frame(sorted.l, names = names(sorted))
# Read in and reshape subgraph frequency data
motcount <- read.csv("~/Desktop/GitHub/Ecological-Networks/FoodWebs/Tables/zscore_both.csv", row.names = 1)
df.freq <- data.frame(motcount)
mfreq <- melt(df.freq[,names(sorted)])
g <- ggplot(mfreq, aes(x = variable, y = value)) + geom_boxplot()
g <- g + geom_line(data = sort.qss, aes(x = 1:13, y = sorted), size = 1.5)
g <- g + geom_point(data = sort.qss, aes(x = 1:13, y = sorted), size = 4, col = "blue")
g <- g + geom_line(data = sort.qss.l, aes(x = 1:13, y = sorted.l), size = 1.5)
g <- g + geom_point(data = sort.qss.l, aes(x = 1:13, y = sorted.l), size = 4, col = "darkred")
g <- g + geom_hline(aes(yintercept = 0), lty = 2, col = "red")
g + xlab("Subgraph") + ylab("Frequency")
citation("igraph")
g <- ggplot(mfreq, aes(x = variable, y = value)) + geom_boxplot()
g <- g + geom_line(data = sort.qss, aes(x = 1:13, y = sorted), size = 1.5)
g <- g + geom_point(data = sort.qss, aes(x = 1:13, y = sorted), size = 4, col = "blue")
g <- g + geom_line(data = sort.qss.l, aes(x = 1:13, y = sorted.l), size = 1.5)
g <- g + geom_point(data = sort.qss.l, aes(x = 1:13, y = sorted.l), size = 4, col = "darkred")
g <- g + geom_hline(aes(yintercept = 0), lty = 2, col = "red")
g + xlab("Subgraph") + ylab("Frequency")
require(ggplot2)
g <- ggplot(mfreq, aes(x = variable, y = value)) + geom_boxplot()
source('~/Desktop/GitHub/Subgraph-Stability/Rscripts/motifAnalysis.R', echo=TRUE)
df.freq
apply(df.freq, 2, function(x){sum(x > 0)})
apply(df.freq, 2, function(x){sum(x > 0)/50})
6/16
df.freq
pca(df.freq)
princomp(df.freq)
plot(princomp(df.freq))
biplot(princomp(df.freq))
df.freq
library(igraph)
library(NetIndices)
library(reshape2)
library(ggplot2)
library(devtools)
library(vegan)
url <- "https://raw.github.com/jjborrelli/Ecological-Networks/master/Food%20Webs/Rscripts/web_functions.R"
source_url(url)
url <- "https://raw.githubusercontent.com/jjborrelli/Ecological-Networks/master/FoodWebs/Rscripts/web_functions.R"
source_url(url)
u <- "https://raw.githubusercontent.com/jjborrelli/Ecological-Networks/master/FoodWebs/Rscripts/web_functions.R"
source_url(u)
inputs <- get_webs("~/Dropbox/Food Web Database/Food_Web/Edgelist")
?source_url
source_url("https://raw.githubusercontent.com/jjborrelli/Ecological-Networks/master/FoodWebs/Rscripts/web_functions.R")
source("~/Desktop/GitHub/Ecological-Networks/FoodWebs/Rscripts/web_functions.R")
inputs <- get_webs("~/Dropbox/Food Web Database/Food_Web/Edgelist")
web.graphs <- inputs$graph.list
web.matrices <- inputs$adjacency.list
webnames <- inputs$webnames
fw.stab <- eig.analysis(10, web.matrices, mode = "unif")
fw.stab
eig.analysis
fw.stab
web.matrices
system.time(
fw.stab <- eig.analysis(1000, web.matrices, mode = "unif")
)
fw.stab
apply(fw.stab, 2, function(x){sum(x<0)})
apply(fw.stab, 2, function(x){sum(x<0)/1000})
6000/60
mot.lst
sapply(mot.lst, sum)
apply(fw.stab, 2, function(x){sum(x<0)/1000})
web.matrices[[1]]
tm <- web.matrices[[1]]
matrices <- web.matrices[[1]]
cols <- length(matrices)
rows <- n
eigenMATRIX <- matrix(nrow = rows, ncol = cols)
ranmat <- lapply(matrices, ran.unif)
matrices <- web.matrices[1]
cols <- length(matrices)
rows <- n
eigenMATRIX <- matrix(nrow = rows, ncol = cols)
ranmat <- lapply(matrices, ran.unif)
ranmat
sum(ranmat < 0)
sum(ranmat[[1]] < 0)
sum(ranmat[[1]] > 0)
ranmat[[1]] > 0
79*79
matrices
sum(matrices[[1]] == 1)
conversion <- function(tm){
for(i in 1:nrow(tm)){
for(j inn 1:ncol(tm)){
if(tm[i,j] == 1){tm[j,i] <- -1}
}
}
return(tm)
}
conversion <- function(tm){
for(i in 1:nrow(tm)){
for(j in 1:ncol(tm)){
if(tm[i,j] == 1){tm[j,i] <- -1}
}
}
return(tm)
}
webmats <- lapply(web.matrices, conversion)
sum(webmats[[1]])
fw.stab <- eig.analysis(10, web.matrices, mode = "lnorm")
fw.stab
apply(fw.stab, 2, function(x){sum(x<0)/1000})
apply(fw.stab, 2, function(x){sum(x<0)/10})
fw.stab <- eig.analysis(10, webmats, mode = "unif")
fw.stab
apply(fw.stab, 2, function(x){sum(x<0)/10})
node.props <- read.csv("Tables/NODEproperties.csv", row.names = 1)
setwd("~/Desktop/GitHub/Ecological-Networks/Food Webs")
setwd("~/Desktop/GitHub/Ecological-Networks/FoodWebs")
node.props <- read.csv("Tables/NODEproperties.csv", row.names = 1)
node.props
head(node.props)
aggregate(node.props$TL, by = list(L1), max)
aggregate(node.props$TL, by = list("L1"), max)
aggregate(node.props$TL, by = list(node.props$L1), max)
maxTL<- aggregate(node.props$TL, by = list(node.props$L1), max)
head(maxTL)
plot(maxTL$x)
fw.stab <- eig.analysis(10, webmats, mode = "lnorm")
fw.stab
apply(fw.stab, 2, function(x){sum(x<0)/10})
reps = 1000
reps = 1000
system.time(
fw.stab.u <- eig.analysis(reps, webmats, mode = "unif")
)
fwQSSu <- apply(fw.stab.u, 2, function(x){sum(x<0)/reps})
system.time(
fw.stab.l <- eig.analysis(reps, webmats, mode = "lnorm")
)
fwQSSl <- apply(fw.stab.l, 2, function(x){sum(x<0)/reps})
3962/60
fwQSSu
fwQSSl
plot(maxTL$x, fwQSSu)
?betareg()
require(betareg)
?betareg()
abline(betareg(fwQSSu~(maxTL$x +.000000000001)))
betareg(fwQSSu~(maxTL$x +.000000000001))
x <- (maxTL$x +.000000000001)
betareg(fwQSSu~x
)
betareg(x~fwQSSu)
x
betareg(fwQSSu+.000000001~maxTL$x)
y = fwQSSu + 0.000000000001
betareg(y~maxTL$x)
y
y = fwQSSu + 0.000001
betareg(y~maxTL$x)
betareg(y~maxTL$x)$fitted
lines(betareg(y~maxTL$x)$fitted)
lines(lm(y~maxTL$x)$fitted)
lines(lm(y~maxTL$x)$fitted, col = "blue")
lm(y~maxTL$x)
4.1/9
sqrt(.4555)
sqrt(4.1/11)
eig.analysis <- function(n, matrices, mode = "unif"){
cols <- length(matrices)
rows <- n
eigenMATRIX <- matrix(0, nrow = rows, ncol = cols)
for(i in 1:n){
if(mode == "unif"){
ranmat <- lapply(matrices, ran.unif)
}else if(mode == "lnorm"){
ranmat <- lapply(matrices, ran.lnorm)
}
eigs <- sapply(ranmat, maxRE)
eigenMATRIX[i,] <- eigs
}
return(eigenMATRIX)
}
n <- 10000
system.time(
mot.stab<- eig.analysis(n, mot.lst, mode = "unif")
)
n <- 5000
system.time(
mot.stab<- eig.analysis(n, mot.lst, mode = "unif")
)
?profile
?Tukey
?TukeyHSD
require(devtools)
install_github("hadley/devtools")
install.packages(c("cluster", "devtools", "foreach", "gdata", "httpuv", "iterators", "jsonlite", "lattice", "markdown", "Matrix", "mgcv", "mvtnorm", "nlme", "sp"))
install.packages(c("cluster", "devtools", "foreach", "gdata",
)
install.packages("devtools")
install.packages(c("cluster", "foreach", "gdata", "httpuv"))
install.packages(c("iterators", "jsonlite", "lattice", "markdown", "mgcv", "mvtnorm", "sp"))
install.packages(c("iterators", "jsonlite", "lattice", "markdown",
install.packages("iterators")
install.packages("jsonlite")
install.packages("lattice")
library("lattice", lib.loc="/Library/Frameworks/R.framework/Versions/3.0/Resources/library")
detach("package:lattice", unload=TRUE)
install.packages(c("markdown", "Matrix", "mgcv", "mvtnorm", "nlme", "sp"))
install.packages("lattice")
install.packages("lattice")
require(RCurl)
?getURL
?source_url
require(devtools)
?source_url
source_url("https://gist.github.com/hadley/6872663/raw/hi.r")
source_url("https://raw.githubusercontent.com/keepsimpler/ecological-network/master/nestedness.R")
library(RCurl)
options(RCurlOptions = list(cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl")))
getURL("https://raw.githubusercontent.com/jjborrelli/Ecological-Networks/master/FoodWebs/Rscripts/web_functions.R")
