mat <- matrix(nrow = 10, ncol = 10)
mat
for(i in 1:10){
for(j in 1:10){
mat[i,j]<- 1
}
}
mat
mat <- matrix(nrow = 10, ncol = 10)
for(i in 1:10){
for(j in 1:5){
mat[i,j]<- 0
}
}
mat
?tidy
??tidy
library(formatR)
tidy(yang1.R)
tidy.source(yang1.R)
tidy.source("~/Desktop/yang1.R")
tidy.source("~/Desktop/yang1.R", output = T, file = "~/Desktop/yang2)
tidy.source("~/Desktop/yang1.R", output = T, file = "~/Desktop/yang2")
tidy.source("~/Desktop/yang1.R", output = T, file = "~/Desktop/yang2.R")
example <- sample(1:6, size = 55, replace = T, prob = NULL)
example
sum(example == 1)
bl <- sum(example == 1)
br <- sum(example == 2)
gr <- sum(example == 3)
re <- sum(example == 4)
or <- sum(example == 5)
ye <- sum(example == 6)
ye <- sum(example == 6)
c(bl, br, gr, re, or, ye)
bags <- matrix(nrow = 1, ncol = 6)
bags[1,] <- c(bl, br, gr, re, or, ye)
bags
example
as.numeric(sum(example == 6))
as.numeric(sum(example == 1))
# My Combination of m&m's from my bag in a vector
mybag<-c(4,14,11,14,8,6)
for(i in 1:10000){
mm<-sample(c('blue','brown','green','orange','red','yellow'),57, replace=TRUE, prob= c(.24,.14,.16,.19,.18,.14))
mmtable<-table(mm)
numbermm<-as.numeric(mmtable)
if (all(numbermm == mybag)) {
print("Match")
}
}
mm<-sample(c('blue','brown','green','orange','red','yellow'),57, replace=TRUE, prob= c(.24,.14,.16,.19,.18,.14))
mmtable<-table(mm)
mmtable
numbermm<-as.numeric(mmtable)
numbermm
actual.prob <- c(.14, .14, .16, .13, .19, .24)
hannah <- matrix(nrow = 2000000, ncol = 6)
example <- replicate(2000000,sample(1:6, 58, replace = T, actual.prob))
example <- replicate(1000000,sample(1:6, 58, replace = T, actual.prob))
hannah <- matrix(nrow = 1000000, ncol = 6)
for(i in 1:1000000){
hannah[i,] <- c((sum(example[,i] ==1)),(sum(example[,i] ==2)), (sum(example[,i] == 3)),(sum(example[,i]==4)), (sum(example[,i] == 5)), (sum(example[,i] ==6 )))
}
y <- c()
for(i in 1:1000000){
y[i] <- sum(hannah[i,] == number.in.bag)
}
number.in.bag = c(10, 14, 7, 11, 12, 15)
sum(number.in.bag)
number.in.bag = c(10, 14, 7, 11, 12, 5)
number.in.bag = c(10, 14, 7, 11, 12, 5)
sum(number.in.bag)
number.in.bag = c(8, 14, 7, 11, 9, 6)
y <- c()
for(i in 1:1000000){
y[i] <- sum(hannah[i,] == number.in.bag)
}
y
sum(y == 6)
install.packages("raster")
library(raster)
?getData
wclimDATA <- getData('worldclim', var = 'bio', res = 10)
head(wclimdata)
head(wclimDATA)
dim(wclimDATA)
summary(wclimDATA)
str(wclimDATA)
wclimDATA <- getData('worldclim', var = 'tmin', res = 10)
head(wclimDATA)
barplot(wclimDATA)
dataType(wclimDATA)
read.csv("~/Desktop/Temperature/threemonth.csv")
temps <- read.csv("~/Desktop/Temperature/threemonth.csv")
rm(wclimDATA)
mean(temps$temp_march)
mean(temps$temp_mar)
temps$mardiff <- temps$temp_mar - mean.mar
mean.mar <- mean(temps$temp_mar)
temps$mardiff <- temps$temp_mar - mean.mar
temps
?slope
??slope
pred <- read.csv("~/Desktop/Temperature/pred.csv")
sum(pred$shadow_seen == 1)
sum(pred$shadow_seen == 1, na.rm = T)
sum(pred$shadow_seen == , na.rm = T)
sum(pred$shadow_seen == 0, na.rm = T)
temps
subset.temp <- temps[6:113,]
plot(temps$mardiff, pred$shadow_seen)
plot(temps$mardiff, pred$shadow_seen, na.rm)
pred <- read.csv("~/Desktop/Temperature/pred.csv")
sum(pred$shadow_seen == 0)
plot(temps$mardiff, pred$shadow_seen, na.rm)
plot(subset.temp$mardiff, pred$shadow_seen, na.rm)
plot(subset.temp$mardiff, pred$shadow_seen)
length(subset.tem$mardiff)
length(subset.temp$mardiff)
length(pred$shadow_seen)
subset.temp
pred
plot(subset.temp$mardiff, pred$shadow_seen[1:108,])
plot(subset.temp$mardiff, pred[1:108,]$shadow_seen)
x <- subset.temp$mardiff
y <- pred[1:108,]$shadow_seen
glm(y~x)
glm(y~x, family = "binomial")
summary(glm(y~x, family = "binomial"))
abline(glm(y~x, family = "binomial"))
?predict
predict(glm(y~x, family = "binomial"))
predict(glm(y~x, family = "binomial"), type = "response")
predict(glm(y~x, family = "binomial"), data.frame(Size = seq(-6,6,.1)), type = "response")
p <- predict(glm(y~x, family = "binomial"), data.frame(Size = seq(-6,6,.1)), type = "response")
lines(p ~ seq(-6,6,.1))
p <- predict(glm(y~x, family = "binomial"), data.frame(Size = sort(subset.temp$mardiff), type = "response")
p <- predict(glm(y~x, family = "binomial"), data.frame(Size = sort(subset.temp$mardiff)), type = "response")
lines(p ~ sort(subset.temp$mardiff)))
lines(p ~ sort(subset.temp$mardiff))
library(deSolve)
predpreyRM <- function(t, y, params){
N <- y[1]
P <- y[2]
with(as.list(params), {
dN.dt <- r * N * (1 - (N / K)) - (a * N * P) / (1 + a * h * N)
dP.dt <- e * (a * N * P) / (1 + a * h * N) - s * P
return(list(c(dN.dt, dP.dt)))
})
}
params <- matrix(nrow = 1, ncol = 6)
colnames(params) <- c("r", "K", "a", "h", "e", "s")
params[1,] <- c(2, 1000, .5, .001, .1, .3)
t <- seq(1, 100, .1)
state1 <- c(N = 100, P = 5)
state2 <- c(N = 150, P = 10)
state3 <- c(N = 200, P = 20)
out1 <- ode(y = state1, times = t, func = predpreyRM, parms = params[1, ])
plot(out)
plot(out1)
library(rootSolve)
install.packages("rootSolve")
library(rootSolve)
jacobian.full(state1, predpreyRM)
jacobian.full(state1, predpreyRM, times = t, parms = params[1,])
jacobian.full(state1, predpreyRM, parms = params[1,])
out1
jacobian.full(state2, predpreyRM, parms = params[1,])
max(Re(eigen(jacobian.full(state2, predpreyRM, parms = params[1,]))))
max(Re(eigen(as.matrix(jacobian.full(state2, predpreyRM, parms = params[1,])))))
x <- jacobian.full(state2, predpreyRM, parms = params[1,])
str(x)
dim(x)
is.matrix(x)
eigen(x)
max(Re(eigen(x)$values))
x <- jacobian.full(c(state1, state2, state3), predpreyRM, parms = params[1,])
x
x <- jacobian.full(state1, predpreyRM, parms = params[1,])
is.matrix(x)
max(Re(eigen(x)$values))
x <- jacobian.full(state2, predpreyRM, parms = params[1,])
is.matrix(x)
max(Re(eigen(x)$values))
x <- jacobian.full(state3, predpreyRM, parms = params[1,])
is.matrix(x)
max(Re(eigen(x)$values))
state3 <- c(N = 2000, P = 200)
x <- jacobian.full(state3, predpreyRM, parms = params[1,])
is.matrix(x)
max(Re(eigen(x)$values))
x <- jacobian.full(state3, predpreyRM, parms = params[1,])
max(Re(eigen(x)$values))
state3 <- c(N = 20000, P = 20)
,
is.matrix(x)
max(Re(eigen(x)$values))
x <- jacobian.full(state3, predpreyRM, parms = params[1,])
is.matrix(x)
max(Re(eigen(x)$values))
library(igraph)
library(NetIndices)
library(reshape2)
library(ggplot2)
library(devtools)
url <- "https://raw.github.com/jjborrelli/Ecological-Networks/master/Projects/Food%20Webs/Rscripts/web_functions.R"
source_url(url)
url <- "https://raw.github.com/jjborrelli/Ecological-Networks/master/Food%20Webs/Rscripts/web_functions.R"
source_url(url)
setwd("~/Desktop/GitHub/Ecological-Networks/Food Webs")
setwd("~/Desktop/GitHub/Ecological-Networks/Food Webs")
fw.indices <- read.csv("Tables/FWindices.csv")
node.props <- read.csv("Tables/NODEproperties.csv")
fw.indices
motif.df <- read.csv("Tables/motifCOUNTS.csv")
motif.df
system.time(
nulltest <- null_motifs(web.graphs, graph.names = webnames, sample = 1000, iter = 1000)
)
inputs <- get_webs("~/Dropbox/Database/Food Web Database/Food_Web/Edgelist")
inputs <- get_webs("~/Dropbox/Food Web Database/Food_Web/Edgelist")
web.graphs <- inputs$graph.list
web.matrices <- inputs$adjacency.list
webnames <- inputs$webnames
system.time(
nulltest <- null_motifs(web.graphs, graph.names = webnames, sample = 1000, iter = 1000)
)
1325/60
nulltest
nullmeans <- apply(nulltest[,2:14], 2, mean)
nullsd <- apply(nulltest[,2:14], 2, sd)
motif.means <- apply(motif.df, 2, mean)
warnings()
motif.df
motif.means <- apply(motif.df[2:14], 2, mean)
motif.means
motif.means <- apply(motif.df[,2:14], 2, mean)
motif.means
motif.df <- read.csv("Tables/motifCOUNTS.csv", header = T)
getwd()
setwd("~/Desktop/GitHub/Ecological-Networks/Food Webs")
motif.df <- read.csv("Tables/motifCOUNTS.csv", header = T)
motif.df
colnames(motif.df)
motif.df <- read.data.frame("Tables/motifCOUNTS.csv", header = T)
motif.df <- read.dataframe("Tables/motifCOUNTS.csv", header = T)
motif.df <- read.tabel("Tables/motifCOUNTS.csv", header = T)
motif.df <- read.table("Tables/motifCOUNTS.csv", header = T)
motif.df <- read.table("Tables/motifCOUNTS.csv", header = T, sep = ",")
motif.df
motif.means <- apply(motif.df[,3:15], 2, mean)
motif.means
motif.df
motif.means
?quantile
apply(motif.df[,3:15], 2, quantile, probs = c(0.025, 0.975))
nullmeans
nullsd
plot((motif.means - nullmeans) / nullsd, typ = "o", lty = 2, ylim = c(-.5, .5), xlim = c(1, 13))
zmat.df <- melt(as.data.frame(z.mat))
# Combine all means into a single matrix with each row a web, and each column a motif
# Each value is the average of "sample" number of iterations
nwm <- matrix(unlist(null.web.means), nrow = 50, ncol = 13, byrow = T)
# Same for standard deviation
nwsd <- matrix(unlist(null.web.sd), nrow = 50, ncol = 13, byrow = T)
# Redefine the motif frequencies as a matrix
mot.mat <- as.matrix(motif.df[,2:14])
# Calculate the z-score as (freq - mean_rewired) / sd_rewired
z.mat <- (mot.mat - nwm) / nwsd
z.mat.norm <- z.mat / colSums(z.mat^2)
# Boxplot is probably the nicest way to visualize the distributions of z.scores for each motif
par(mfrow = c(1,2))
zmat.df <- melt(as.data.frame(z.mat))
mot.pro <- ggplot(zmat.df, aes(x = variable, y = value)) + geom_boxplot()
mot.pro + geom_hline(aes(yintercept = 0))
# Split giant dataframe (outputt of null_motifs) into a list with each list item its own web
websplit <- split(nulltest, nulltest$web)
# Calculate column means and standard deviations for each web
null.web.means <- lapply(websplit, function(x){
y<-x[,2:14]
apply(y, 2, mean)})
null.web.sd <- lapply(websplit, function(x){
y<-x[,2:14]
apply(y, 2, sd)})
# Combine all means into a single matrix with each row a web, and each column a motif
# Each value is the average of "sample" number of iterations
nwm <- matrix(unlist(null.web.means), nrow = 50, ncol = 13, byrow = T)
# Same for standard deviation
nwsd <- matrix(unlist(null.web.sd), nrow = 50, ncol = 13, byrow = T)
# Redefine the motif frequencies as a matrix
mot.mat <- as.matrix(motif.df[,2:14])
# Calculate the z-score as (freq - mean_rewired) / sd_rewired
z.mat <- (mot.mat - nwm) / nwsd
z.mat.norm <- z.mat / colSums(z.mat^2)
# Boxplot is probably the nicest way to visualize the distributions of z.scores for each motif
par(mfrow = c(1,2))
zmat.df <- melt(as.data.frame(z.mat))
mot.pro <- ggplot(zmat.df, aes(x = variable, y = value)) + geom_boxplot()
mot.pro + geom_hline(aes(yintercept = 0))
ggsave(filename = "motif_profile1.jpeg", height = 15, width = 15, units = "cm")
zmatnorm.df <- melt(as.data.frame(z.mat.norm))
mot.pro.norm <- ggplot(zmatnorm.df, aes(x = variable, y = value), na.rm = T) + geom_boxplot()
mot.pro.norm + geom_hline(aes(yintercept = 0))
nwsd
mot.mat <- as.matrix(motif.df[,3:15])
z.mat <- (mot.mat - nwm) / nwsd
z.mat.norm <- z.mat / colSums(z.mat^2)
par(mfrow = c(1,2))
zmat.df <- melt(as.data.frame(z.mat))
mot.pro <- ggplot(zmat.df, aes(x = variable, y = value)) + geom_boxplot()
mot.pro + geom_hline(aes(yintercept = 0))
zmatnorm.df <- melt(as.data.frame(z.mat.norm))
mot.pro.norm <- ggplot(zmatnorm.df, aes(x = variable, y = value), na.rm = T) + geom_boxplot()
mot.pro.norm + geom_hline(aes(yintercept = 0))
motif.quantiles <- apply(motif.df[,3:15], 2, quantile, probs = c(0.025, 0.975))
motif.quantiles[1,]
motif.quantiles <- apply(zmatnorm.df, 2, quantile, probs = c(0.025, 0.975))
zmatnorm.df
motif.quantiles <- apply(zmatnorm.df, 2, quantile, probs = c(0.025, 0.975), na.rm = TRUE)
z.mat.norm
motif.quantiles <- apply(z.mat.norm, 2, quantile, probs = c(0.025, 0.975), na.rm = TRUE)
motif.quantiles
mot.pro.norm <- ggplot(zmatnorm.df, aes(x = variable, y = value), na.rm = T) + geom_boxplot()
mot.pro.norm <- mot.pro.norm + geom_hline(aes(yintercept = 0))
mot.pro.norm + geom_points(motif.quantiles[1,] ))
mot.pro.norm + geom_points(motif.quantiles[1,])
mot.pro.norm + geom_point(motif.quantiles[1,])
mot.pro.norm + geom_point(aes(x = 1:13, y = motif.quantiles[1,]))
motif.quantiles[1,]
mot.pro.norm + geom_point(aes(x = 1:13, y = motif.quantiles[1,]), color = "blue")
mot.pro.norm + geom_point(aes(x = 1:13, y = motif.quantiles[2,]), color = "blue")
mot.pro.norm <- ggplot(zmatnorm.df, aes(x = variable, y = value), na.rm = T) + geom_boxplot()
mot.pro.norm <- mot.pro.norm + geom_hline(aes(yintercept = 0))
mot.pro.norm <- mot.pro.norm + geom_point(aes(x = 1:13, y = motif.quantiles[1,]), color = "blue")
mot.pro.norm + geom_point(aes(x = 1:13, y = motif.quantiles[2,]), color = "blue")
mot.pro.norm <- ggplot(zmatnorm.df, aes(x = variable, y = value), na.rm = T) + geom_boxplot()
mot.pro.norm <- mot.pro.norm + geom_hline(aes(yintercept = 0))
mot.pro.norm
ggsave(filename = "motif_profile2.jpeg", height = 15, width = 15, units = "cm")
library(vegan)
?permatswap
web.matrices[[1]]
testing <- web.matrices[[1]]
permatswap(testing, times = 10)
permuted <- permatswap(testing, times = 10)
plot(permuted)
plot(permuted)
dev.off9
dev.off()
plot(permuted)
permuted$perm
lapply(permuted$perm, dim)
dim(testing)
permuted.graphs <- lapply(permuted$perm, graph.adjacency)
motif_counter(permuted.graphs)
motif_counter(permuted.graphs, webs = LETTERS[1:10])
permuted <- permatswap(testing, times = 1000)
permuted.graphs <- lapply(permuted$perm, graph.adjacency)
motif_counter(permuted.graphs, webs = as.character(1:100))
motif_counter(permuted.graphs, webs = as.character(1:1000))
p.motif <- motif_counter(permuted.graphs, webs = as.character(1:1000))
colMeans(p.motif)
colMeans(p.motif[2:14])
permuted <- permatswap(testing, fixedmar = "rows", times = 1000)
permuted <- permatfull(testing, fixedmar = "rows", mtype = "prab", times = 1000)
permuted.graphs <- lapply(permuted$perm, graph.adjacency)
p.motif <- motif_counter(permuted.graphs, webs = as.character(1:1000))
colMeans(p.motif[2:14])
permuted2 <- permatfull(testing, fixedmar = "columns", mtype = "prab", times = 1000)
plot(permuted)
permuted.graphs2 <- lapply(permuted$perm, graph.adjacency)
p.motif2 <- motif_counter(permuted.graphs, webs = as.character(1:1000))
colMeans(p.motif2[2:14])
p.motif2 <- motif_counter(permuted.graphs2, webs = as.character(1:1000))
colMeans(p.motif2[2:14])
permuted.graphs2 <- lapply(permuted2$perm, graph.adjacency)
p.motif2 <- motif_counter(permuted.graphs2, webs = as.character(1:1000))
colMeans(p.motif2[2:14])
motif.means
plot(colMeans(p.motif), colMeans(p.motif2))
plot(colMeans(p.motif[,2:14]), colMeans(p.motif2[2:14]))
abline(0,1)
what <- c(rnorm(5), rnorm(5, -0.094 ,1.065)) #this is my histogram for n1=5
ami <- c(rnorm(50), rnorm(50, 0.046, 0.80)) #this is my histogram for n1=50
doing <- c(rnorm(500), rnorm(500, 0.066, 0.96)) #this is my histogram for n1=500
plot(what, col="red") #why won't the colors work
plot(ami, col="purple")
plot(doing, col="green")
?histogram
??histogram
plot(what, col="red") #why won't the colors work
plot(ami, col="purple")
plot(doing, col="green")
plot(density(what)) #this allows me to plot all my histograms on one plot
lines(density(ami))
lines(density(doing))
permuted2
web_permutation <- function(webmatrices, fixedmar, times){
if (!is.list(webmatrices)){
webmatrices <- list(webmatrices)
warning("not a list")
}
len <- length(webmatrices)
p.motif <- list()
for (i in 1:len){
permuted <- permatfull(webmatrices[[i]], fixedmar = fixedmar, mtype = "prab", times = times)
permuted.graphs <- lapply(permuted2$perm, graph.adjacency)
p.motif[[i]] <- motif_counter(permuted.graphs, webs = as.character(1:times))
}
return(p.motif)
}
permutes <- web_permutation(web.matrices, fixedmar = "columns", times = 25)
permutes
web.matrices
length(web.matrices)
permuted2 <- permatfull(testing, fixedmar = "columns", mtype = "prab", times = 25)
permuted.graphs2 <- lapply(permuted2$perm, graph.adjacency)
permuted.graphs2
p.motif2 <- motif_counter(permuted.graphs2, webs = as.character(1:25))
p.motif2
length(permutes)
length(permutes[[1]])
permutes[[1]]
dim(permutes[[1]])
motif_counter
i=2
permuted <- permatfull(webmatrices[[i]], fixedmar = fixedmar, mtype = "prab", times = times)
webmatrices = web.matrices
times = 2
permuted <- permatfull(webmatrices[[i]], fixedmar = fixedmar, mtype = "prab", times = times)
fixedmar="columns"
permuted <- permatfull(webmatrices[[i]], fixedmar = fixedmar, mtype = "prab", times = times)
permuted
permuted.graphs <- lapply(permuted2$perm, graph.adjacency)
permuted.graphs
motif_counter(permuted.graphs, webs = as.character(1:times))
rm(fixedmar)
rm(times)
rm(webmatrices)
rm(i)
web_permutation <- function(webmatrices, fixedmar, times){
require(vegan)
if (!is.list(webmatrices)){
webmatrices <- list(webmatrices)
warning("not a list")
}
len <- length(webmatrices)
p.motif <- list()
for (i in 1:len){
permuted <- permatfull(webmatrices[[i]], fixedmar = fixedmar, mtype = "prab", times = times)
permuted.graphs <- lapply(permuted$perm, graph.adjacency)
p.motif[[i]] <- motif_counter(permuted.graphs, webs = as.character(1:times))
}
return(p.motif)
}
permutes <- web_permutation(web.matrices, fixedmar = "columns", times = 25)
permutes
apply(permutes, 2, FUN = function(x){colMeans(x[2:14])})
apply(permutes, 2, FUN = function(x){colMeans(x[,2:14])})
lapply(permutes, 2, FUN = function(x){colMeans(x[,2:14])})
lapply(permutes, FUN = function(x){colMeans(x[,2:14])})
p.means <- lapply(permutes, FUN = function(x){colMeans(x[,2:14])})
unlist(p.means)
matrix(unlist(p.means), ncol = 13, nrow = 50)
matrix(unlist(p.means), ncol = 13, nrow = 50, byrow = T)
boxplot(matrix(unlist(p.means), ncol = 13, nrow = 50, byrow = T))
pmeanmat <- matrix(unlist(p.means), ncol = 13, nrow = 50, byrow = T))
pmeanmat <- matrix(unlist(p.means), ncol = 13, nrow = 50, byrow = T)
mot.mat
mot.mat - pmeanmat
p.sd <- lapply(permutes, FUN = function(x){sd(x[,2:14])})
p.sd <- lapply(permutes, FUN = function(x){apply(x[,2:14], 2, sd)})
p.sd
psdmat <- matrix(unlist(p.sd), ncol = 13, nrow = 50, byrow = T)
(mot.mat - pmeanmat) / psdmat
boxplot((mot.mat - pmeanmat) / psdmat)
zscor <- (mot.mat - pmeanmat) / psdmat
znorm <- zscor/colSums(zscor^2)
boxplot(znorm)
permutes <- web_permutation(web.matrices, fixedmar = "rows", times = 25)
p.means <- lapply(permutes, FUN = function(x){colMeans(x[,2:14])})
pmeanmat <- matrix(unlist(p.means), ncol = 13, nrow = 50, byrow = T)
p.sd <- lapply(permutes, FUN = function(x){apply(x[,2:14], 2, sd)})
psdmat <- matrix(unlist(p.sd), ncol = 13, nrow = 50, byrow = T)
zscor <- (mot.mat - pmeanmat) / psdmat
znorm <- zscor/colSums(zscor^2)
boxplot(znorm)
permutes <- web_permutation(web.matrices, fixedmar = "both", times = 25)
p.means <- lapply(permutes, FUN = function(x){colMeans(x[,2:14])})
pmeanmat <- matrix(unlist(p.means), ncol = 13, nrow = 50, byrow = T)
p.sd <- lapply(permutes, FUN = function(x){apply(x[,2:14], 2, sd)})
psdmat <- matrix(unlist(p.sd), ncol = 13, nrow = 50, byrow = T)
zscor <- (mot.mat - pmeanmat) / psdmat
znorm <- zscor/colSums(zscor^2)
boxplot(znorm)
abline(h=0)
znorm
zscor
colSums(zscor^2)
colSums(zscor^2, na.rm = T)
znorm <- zscor/colSums(zscor^2, na.rm = T)
boxplot(znorm)
abline(h=0)
permutes <- web_permutation(web.matrices, fixedmar = "both", times = 1000)
p.means <- lapply(permutes, FUN = function(x){colMeans(x[,2:14])})
pmeanmat <- matrix(unlist(p.means), ncol = 13, nrow = 50, byrow = T)
p.sd <- lapply(permutes, FUN = function(x){apply(x[,2:14], 2, sd)})
psdmat <- matrix(unlist(p.sd), ncol = 13, nrow = 50, byrow = T)
zscor <- (mot.mat - pmeanmat) / psdmat
znorm <- zscor/colSums(zscor^2, na.rm = T)
boxplot(znorm)
