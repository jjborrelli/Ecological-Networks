The Southern Ocean Food Web
========================================================
```{r echo = F}
opts_chunk$set(message = F, comment = NA, fig.width = 7, fig.height = 7)
```


Load required libraries: 

```{r}
require(igraph)
require(NetIndices)
require(reshape2)
require(ggplot2)
require(devtools)
require(vegan)
```

Source code for functions to describe web properties

```{r}
url <- "https://raw.github.com/jjborrelli/Ecological-Networks/master/Food%20Webs/Rscripts/web_functions.R"
source_url(url)
```


Load in the data

```{r}
#s.ocean <- read.csv("http://esapubs.org/archive/ecol/E092/097/diet.csv")
s.ocean <- read.csv("~/Downloads/diet.csv")
```

## Whole Southern Ocean

```{r}
el.df <- data.frame(pred = s.ocean$PREDATOR_NAME, prey = s.ocean$PREY_NAME)
  
SOgraph <- graph.edgelist(unique(as.matrix(el.df[,1:2])))

SOadjacency <- get.adjacency(SOgraph, sparse = F)
```

First take a quick look at what the food web looks like. Here I plot the web by trophic level by setting the layout (code shown below). Nodes are plotted with trophic position along the y-axis and plotted along the x-axis according to a random uniform distribution (`runif(x, 0, 1)`).  

```{r unseenCODE, cache = T, echo = F}
gind <- GenInd(SOadjacency)
tind <- TrophInd(SOadjacency)
```

```{r wholeFW}
par(mar = c(0,0,0,0))
layouts <- matrix(c(runif(gind$N), tind$TL), ncol = 2)
plot.igraph(SOgraph, layout = layouts, vertex.label = NA, edge.arrow.size = .5, 
            vertex.size = 1)
```

The plot of the web is not very helpful because there are so many species and far too many interactions. So looking at some of the whole web statistical properties and node properties may be more useful than just plotting the web.  

The `NetIndices` and `igraph` packages have functions to calculate a number of commonly used food web indices. The function `GenInd` from the `NetIndices` library easily calculates the number of nodes ($N$), total number of links ($L$), link density ($\frac{L}{N} = LD$), and connectance (along with some other indices that are not relevant to this dataset). Connectance in this case is calculated as: $$C = \frac{L}{N*(N-1)}$$  
  
The `diameter` is the single longest path between two nodes. The `average.path.length` is the mean number of links between any two nodes in the web. The clustering coefficient (or `transitivity`) is the probability that the nearest neighbors of a given vertex are themselves connected. A high clustering coefficient is an indication that a network has "small world" properties. The sum of the diagonal elements of the adjacency matrix gives the number of species that are cannibalistic, with links that loop back to themselves.   
  
Species in a food web may be either basal, intermediate, or top. These positions may be determined simply by examining the degree of each node. The number of links pointing towards a node is its in-degree and the number of links pointing away from a node is the out-degree. In-degree is therefore a measure of how many species the node of interest preys upon (generality) while out-degree is the number of predators a given node has (vulnerability). Basal nodes will have an in-degree of 0, and likewise top species will have an out-degree of 0. Once the number of basal and top species are found, the number of intermediate species is simply the remainder. 


```{r webProps, cache = T}
gind <- GenInd(SOadjacency)
diam <- diameter(SOgraph)
avpath <- average.path.length(SOgraph)
cluster <- transitivity(SOgraph)
cannibals <- sum(diag(SOadjacency))

degrees <- degree(SOgraph, mode = "all")
indegrees <- degree(SOgraph, mode = "in")
outdegrees <- degree(SOgraph, mode = "out")

numBas <- length(indegrees[which(indegrees == 0)])
numTop <- length(outdegrees[which(outdegrees == 0)])
basal <- (numBas/gind$N) * 100
top <- (numTop/gind$N) * 100
int <- ((gind$N - (numBas + numTop))/gind$N) * 100

web.props <- data.frame(N = gind$N, L = gind$Ltot, LD = gind$LD, C = gind$C, D = diam,
           AvgPath = avpath, ClCoef = cluster, Can = cannibals, Bas = basal, Top = top, Int = int)
```
```{r echo = F}
print(web.props)
```

There are a total of `r web.props$N` species with `r web.props$L` interactions among them. The longest chain described in this food web is `r web.props$D` but the average chain is 
`r web.props$AvgPath`.  

```{r nodeProps, echo = F, cache = T}
tind <- TrophInd(SOadjacency)
```
  
The short average path length in the food web is made clearer by looking at the distribution of trophic positions in the Southern Ocean Food Web.  

```{r TLplot}
qplot(tind$TL, binwidth = .25, geom = "histogram", 
      xlab = "Trophic Position", ylab = "Frequency")
```

There is a tall bar at trophic level 1 and 2 representing plants and herbivores. There is a single organism, _`r rownames(tind[which(round(tind$TL,1) == 1.5),])`_, with a trophic level between 1 and 2, suggesting that it consumes both plant and animals (a true omnivore). I am unconvinced, however, that the dataset includes a fully sampled food web and that some of those organisms described as basal are not plants, but are crustaceans, or other small organisms.   

  
Most of the species in the food web are "top" predators with `r round(web.props$Top)`% of sampled species having no predators themselves. Plants ("basal species") make up 
`r round(web.props$Bas)`% of the web, and the remaining `r round(web.props$Int)`% are "intermediate". The disproportionately large proportion of "top" species is unusual compared to other empirically described food webs and may be the result of sampling methods. The connectance of the Southern Ocean Food Web is relatively low at `r web.props$C`, but that is expected with such a large number of species.  

The degree distribution of a food web is often described as being power-law distributed, with most nodes having few links, and few nodes having many links. The degree distribution may be plotted as a histogram. Rather than fitting a power law to the distribution I have fit a lognormal distribution to the data, as it appears to be the better fit. In the following plot I have included a line fit to a lognormal (blue) and power law (green) distributions. The lognormal distribution appears to be a better fit to the degree distribution.  
  

```{r degreeDIST, warning = F}
degdisfit <- fitdistr(degrees, "lognormal")
degdispow <- power.law.fit(degrees, force.continuous = T)

dd <- ggplot(data.frame(degrees = degrees), aes(x = degrees))
dd <- dd + geom_histogram(aes(y=..density..), binwidth = 5, colour = "black", fill = "white")

sequ <- seq(1, 300, .25)

dd <- dd + geom_line(aes(x = sequ[1:1095],
                         y = dlnorm(sequ[1:1095], degdisfit[[1]][1], degdisfit[[1]][2])),
                     colour = "blue")
dd <- dd + geom_line(aes(x = sequ[1:1095], y = 20 * sequ[1:1095] ^ -degdispow$alpha, colour = "green"))
dd + scale_y_continuous(limits = c(0, 0.12)) + theme(legend.position = "none")
```


-----------------------------------------------------------
## By location

The following code splits up the dataframe by the location column. The resulting 228 graph objects get stored in `location.g`. _NOTE: the first location is 'blank' `" "` so I assume that it means that there are some rows without a location_  

```{r}
m <- split(s.ocean, f = s.ocean$LOCATION)  
location.g <- list()  
for (i in 1:length(levels(s.ocean$LOCATION))){
  
  el.df <- data.frame(pred = m[[i]]$PREDATOR_NAME, prey = m[[i]]$PREY_NAME)
  
  g <- graph.edgelist(unique(as.matrix(el.df[,1:2])))
  
  location.g[[i]] <- g 
}
```

Plot webs by location, labels `1:228` correspond to `levels(s.ocean$LOCATION)`:

```{r fig.width = 10, fig.height = 200}
par(mfrow = c(114, 2), mar = c(.01,.01,.01,.01))
for (i in 1:228){
  plot.igraph(location.g[[i]], layout = layout.circle, edge.arrow.size = .5, vertex.label = NA,
              vertex.size = 5)
  text(0, 0, label = i, cex = 2)
}
```

```{r locationWEBPROPS, cache = T}
web.props1 <- data.frame()
for (i in 1:228){
  gind <- GenInd(get.adjacency(location.g[[i]], sparse = F))
  diam <- diameter(location.g[[i]])
  avpath <- average.path.length(location.g[[i]])
  cluster <- transitivity(location.g[[i]])
  cannibals <- sum(diag(get.adjacency(location.g[[i]], sparse = F)))

  degrees <- degree(location.g[[i]], mode = "all")
  indegrees <- degree(location.g[[i]], mode = "in")
  outdegrees <- degree(location.g[[i]], mode = "out")

  numBas <- length(indegrees[which(indegrees == 0)])
  numTop <- length(outdegrees[which(outdegrees == 0)])
  basal <- (numBas/gind$N) * 100
  top <- (numTop/gind$N) * 100
  int <- ((gind$N - (numBas + numTop))/gind$N) * 100

  web.props <- data.frame(N = gind$N, L = gind$Ltot, LD = gind$LD, C = gind$C, D = diam,
                          AvgPath = avpath, ClCoef = cluster, Can = cannibals, Bas = basal, 
                          Top = top, Int = int)
  web.props1 <- rbind(web.props1, web.props)
}

print(web.props1)
```

```{r}
ggplot(web.props1) + geom_histogram(aes(x = N), binwidth = 5)
```

```{r}
ggplot(web.props1) + geom_point(aes(x = N, y = C))
```

---------------------------------------------------------------
## By year

```{r}
so.ode <- as.character(s.ocean$OBSERVATION_DATE_END)
so.ode.split <- strsplit(so.ode, split = "/")

year <- c()
for(i in 1:length(so.ode.split)){
  year[i] <- so.ode.split[[i]][3]
}
s.ocean2 <- cbind(s.ocean, year)

m2 <- split(s.ocean2, f = s.ocean2$year)
year.g <- list()  
for (i in 1:length(levels(s.ocean2$year))){
  
  el.df <- data.frame(pred = m[[i]]$PREDATOR_NAME, prey = m[[i]]$PREY_NAME)
  
  g <- graph.edgelist(unique(as.matrix(el.df[,1:2])))
  
  year.g[[i]] <- g  
}

```

Plot webs by year
```{r fig.width = 10, fig.height = 90}
par(mfrow = c(23, 2), mar = c(.01,.01,.01,.01))
for (i in 1:45){
  plot.igraph(year.g[[i]], layout = layout.circle, edge.arrow.size = .5, vertex.label = NA,
              vertex.size = 5)
  text(0, 0, label = levels(s.ocean2$year)[i], cex = 2)
}
```